<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[你好-Hexo]]></title>
    <url>%2F2018%2F04%2F26%2Fabout%2F</url>
    <content type="text"><![CDATA[你好 ….]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fhexo%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、使用Hexo+Github一步步搭建属于自己的博客（基础）​ http://www.cnblogs.com/fengxiongZz/p/7707219.html 2、关于这个博客主题 Hexo-Theme-Buer使用​ https://blog.csdn.net/erchowyo/article/details/54407614/ 3、有哪些好看的 Hexo 主题​ https://www.zhihu.com/question/24422335 4、修改hexo后同步到github ​ hexo clean ​ hexo d ​ hexo g]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssm 笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fssm%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、SpringMVC接口解释（1）DispatcherServlet接口：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给 Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。 是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：（1）截获符合特定格式的URL请求。（2）初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。（3）初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 （2）HandlerMapping接口： 能够完成客户请求到Controller映射。 （3）Controller接口：需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 （4）ViewResolver接口：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。 二、xml文件各种标签属性（1）12341.我们只需在Spring容器能加载到的地方配置bean就可以把自定义类加入到Spring容器中，注意：我们配置的bean是实现类，而不是接口！！ 2.我们可以直接在我们的impl类中配置@service，把相应的类注入到spring容器中。切记这两种方式都可以注入说明：在配置文件中配置bean，其实就是在Spring容器中注入类，这个类在Spring容器中有唯一一个表示id,我们可以通过Spring容器去管理这个类，非常方便（类似ios中的ARC自动释放池）； 三、springmvc常用注解标签（1）@Controller​ 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 ​ @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： （1）在SpringMVC 的配置文件中定义MyController 的bean 对象。 ​ （2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 ​ &lt; context:component-scan base-package = “com.host.app.web” /&gt;//路径写到controller的上一层 （2）@RequestMapping​ RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。 1、 value， method； value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； 2、consumes，produces consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； 3、params，headers params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 （3）@Resource和@Autowired​ @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。 1、共同点 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 2、不同点 @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。 12345public class TestServiceImpl &#123; @Autowired @Qualifier(&quot;userDao&quot;) private UserDao userDao; &#125; @Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 public class TestServiceImpl { // 下面两种@Resource只要使用一种即可 @Resource(name=&quot;userDao&quot;) private UserDao userDao; // 用于字段上 @Resource(name=&quot;userDao&quot;) public void setUserDao(UserDao userDao) { // 用于属性的setter方法上 this.userDao = userDao; } } 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。 @Resource装配顺序： ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。 @Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 （4）、@ModelAttribute和 @SessionAttributes​ 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。 @SessionAttributes即将值放到session作用域中，写在class上面。 使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据 （5）、@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数 123456789101112131415161718192021@Controller public class TestController &#123; @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId, @PathVariable(&quot;roleId&quot;) String roleId)&#123; System.out.println(&quot;User Id : &quot; + userId); System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;; &#125; @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET) public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123; System.out.println(&quot;Product Id : &quot; + productId); return &quot;hello&quot;; &#125; @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;, method = RequestMethod.GET) public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123; System.out.println(&quot;URI Part 1 : &quot; + regexp1); return &quot;hello&quot;; &#125; &#125; （6）、@requestParam@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 （7）、@ResponseBody作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； （8）、@Component相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。 （9）、@Repository用于注解dao层，在daoImpl类上面注解。 ​ 1：@Repository 用于对DAO实现类进行注解。​ 2：@Service 用于对业务层注解，但是目前该功能与 @Component 相同。​ 3：@Constroller用于对控制层注解，但是目前该功能与 @Component 相同。 （10）、@Service首先，在applicationContext.xml文件中加一行： 1&lt;context:component-scan base-package=&quot;com.hzhi.clas&quot;/&gt; 加上这一行以后，将自动扫描路径下面的包，如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml文件定义bean了，类似的还包括@Component、@Repository、@Controller。 比如下面这个类： 1234567@Service(&quot;courseDAO&quot;)@Scope(&quot;prototype&quot;)public class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO&#123; ...... &#125;[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 其作用就相当于applicationContext.xml文件里面的： 1234&lt;bean id=&quot;courseDAO&quot; class=&quot;com.hzhi.course.dao.CourseDAOImpl&quot; scope=&quot;prototype&quot;&gt; ...... &lt;/bean&gt; 四、springmvc视图解析返回html页面报404错误注意配置html视图解析器时，出现了404错误，仔细了解 当一次请求是需要经过两次拦截器，即html–&gt;拦截器–&gt;controller–&gt;拦截器—&gt;html，其中如果按照下面配置，第一次请求拦截器是正确的，第二次拦截就包404错误。 解决方法： 第一种，使用标题配置“html”视图解析器这样配置，个人推荐这种配置。注意这种配置html是没有前缀属性的，所以需要先配置freemarkerConfig，前缀保存在freemarkerConfig中。 第二种，在web.xml中加入下面代码，表示对静态资源.html不拦截。 &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; 第三种，使用 &lt;mvc:resources location=”/“ mapping=”/*/.html”/&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue 笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fvue%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、新建一个vue-cli项目文件1、安装vue脚手架输入：​ vue init webpack exprice 注意这里的“exprice” 是项目的名称可以说是随便的起名，但是需要主要的是“不能用中文” 2、安装依赖输入：​ npm install 3、启动项目输入：​ npm run dev 二、页面间传值this.$router.replace(‘/index’)也可以跳转页面 跳转并传值：​ 123456789methods: &#123; ​ login () &#123; this.$router.push(&#123;name: &apos;index&apos;,params: &#123;username: this.username,password: this.password&#125;&#125;); &#125;​ &#125; 注解：index是将要跳转的一个index.vue页面，params后面是传的参数，先在data里面声明 接收值：​ $route.params.username、$route.params.password接收传过来的两个值 三、父组件往子组件传值父组件可以使用 props 把数据传给子组件。 父组件：​ 注解：component-a是导入的子组件，msgfromfather是要传的key 子组件：​ props: [‘msgfromfather’] //和定义方法、变量一样需要定义 ​ console.log(this.msgfromfather) //可以在方法里面打印出传过来的值 ​ //可以在页面直接显示 四、父组件往子组件传值子组件可以使用 $emit 触发父组件的自定义事件。 子组件：​ this.$emit(“child-speak”,this.msg); //写在方法里面，比如点击之后就执行这个方法，child-speak是父组件自定义的事件 父组件：​ //child-speak是自定义的事件，getchildspeak是方法 ​ getchildspeak: function (msg) { this.childwords = msg;} //通过这个方法就可以得到传过来的msg代表什么值 ​ //显示出来接收到的值 五、路由一、动态路由​ path: ‘/goods/:goodsId/user/:name’ 或者 path: ‘/goods/:goodsId 这是配置路由，: 后面是要携带的参数 ​ $route.params.goodsId ​ 或者 $ route.params.name 这是在跳转后获取携带的参数值 二、嵌套路由路由设置123456789101112131415161718192021export default new Router(&#123; routes: [ &#123; path: &apos;/goods&apos;, name: &apos;GoodsList&apos;, component: GoodsList, children: [ &#123; path: &apos;title&apos;, name: &apos;title&apos;, component: Title &#125;, &#123; path: &apos;image&apos;, name: &apos;image&apos;, component: Image &#125; ] &#125; ]&#125;) GoodsList.vue页面设置12345678&lt;div&gt; 这是商品列表页面&lt;br/&gt; &lt;router-link to=&quot;/goods/title&quot;&gt;显示商品标题&lt;/router-link&gt; &lt;router-link to=&quot;/goods/image&quot;&gt;显示商品图片&lt;/router-link&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
</search>
