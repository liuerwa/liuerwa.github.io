<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F21%2FJS%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cthis%2F</url>
    <content type="text"><![CDATA[JS闭包，作用域，this一、闭包1、变量的作用域要理解闭包，首先必须理解JavaScript特殊的作用域。 变量的作用域分为两种：全局变量和局部变量。 a、函数内部可以直接读取全局变量： 12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 b、函数外部无法读取函数内部的局部变量 1234function f1()&#123; var n=999;&#125;alert(n); // error c、函数内部声明变量时，必须使用var命令。如果不用的话，实际上声明了一个全局变量。 12345function f1()&#123; n=999;&#125;f1();alert(n); // 999 2、如何从外部读取局部变量在函数的内部，再声明一个函数。 123456function f1()&#123; var n=999; function f2()&#123; alert(n); //999 &#125;&#125; 解释：在上述代码中，函数f2就被包括在函数f1里面，函数f1的所有局部变量对f2都是可见的。但是反过来就不行了，f2中的局部变量，在f1中是不可见的。这就是JavaScript语言特有的“链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量，所以，父对象的所有变量，子对象都是可见的，反之则不行。 既然在函数f2中可以读取函数f1中的局部变量，那么我们只要把函数f2作为返回值，就可以在函数f1外面读取它的局部变量了。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 3、闭包的概念上一节代码中的函数f2就是闭包。 我的理解是：闭包是能够读取其他函数内部变量的函数。 由于在JavaScript语言中，只有函数内部的子函数才能访问此函数的局部变量，因此可以简易的把闭包称为“定义在一个函数内部的函数”。 所以，在本质上，闭包是函数内部和函数外部连接的一座桥梁。 自己总结：闭包可以解决函数外部无法访问函数内部变量的问题。 闭包还有一个大的特点就是通过闭包我们可以让函数中的变量持久保持。 1234567function fn()&#123; var num = 5; num+=1; alert(num);&#125; fn(); //6fn(); //6 为什么呢？因为函数一旦调用里面的内容就会被销毁，下一次调用又是一个新的函数，和上一个调用的不相关了。 12345678910function fn()&#123; var num = 0; return function()&#123; num+=1; alert(num); &#125;; &#125; var f = fn();f(); //1f(); //2 我们首页定义了一个fn函数，里面有个num默认为0，接着返回了一个匿名函数（也就是没有名字的函数）。我们在外部用f接收这个返回的函数。这个匿名函数干的事情就是把num加1。 这里之所以执行完这个函数num没有被销毁是因为那个匿名函数的问题，因为这个匿名函数用到了这个num，所以没有被销毁，一直保持在内存中，因此我们f()时num可以一直加。 4、闭包的用途闭包可以用在许多地方。最大的两个用处：一是可以读取到函数内部的变量；二是可以让这些变量的值始终保存在内存中。 1234567891011121314function f1() &#123; var n = 999; nAdd = function () &#123; n += 1 &#125; function f2() &#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在上面代码中，其实result就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在函数f1调用后被自动清除。 为什么会这样呢？原因在于函数f1是函数f2的父函数，而函数f2被赋予了一个全局变量n，导致函数f2始终在内存中，而f2是依赖于f1的，所以f1也存在于内存中，不会在调用结束后，被垃圾回收机制回收。 注意：在上面代码中，”nAdd=function(){n+=1}”这一行，nAdd前面没有使用var，那么它就是一个全局变量。其次，它还是一个匿名函数，而这个匿名函数也是一个闭包，所以nAdd相当于一个setter，可以在函数外部调用它。 5、使用闭包的注意点由于闭包会使得函数中的变量都保存到内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能的问题，在IE中可能会导致内存泄漏。解决方法是，在退出函数时，将不使用的局部变量删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 6、思考题代码片段一： 1234567891011121314var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;, getName:function()&#123; alert(this.name); &#125; &#125;;alert(object.getNameFunc()()); //The Windowobject.getName(); //My Object 解析：object.getNameFunc()返回的是一个匿名函数function(){return this.name;}，此时this指向全局对象window，所以输出The Window；object.getName()的上下文是object，所以输出My Object。 代码片段二： 1234567891011var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //My Object 解析：getNameFunc 匿名函数属于object对象的函数,this 赋给 that,导致最后return的函数依赖getNameFunc ，不会被回收。 二、js中this的指向1、this的一般情况this的指向在函数定义的时候是不明确的，只有在函数被调用执行时才能确定其指向，实际上this最终指向的是那个调用他的对象。 例子1： 123456function a()&#123; var user = "追梦子"; console.log(this.user); //undefined console.log(this); //Window&#125;a(); //等价于 window.a(); 这里的函数a实际上是被Window对象点击出来的，所以this指向的就是Window。 例子2： 1234567var o = &#123; user:"追梦子", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;o.fn(); //等价于 window.o.fn(); 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o。 例子3： 12345678910var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //12 &#125; &#125;&#125;o.b.fn(); 补充： 12345678910var o = &#123; a:10, b:&#123; // a:12, fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 特殊： 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); this永远指向最后调用他的对象。虽然fn是被b所引用，但是在给j赋值的时候并没有调用指向fn，而最后是window调用j来执行的，所以this指向windo。 2、构造函数版this12345function Fn()&#123; this.user = "追梦子";&#125;var a = new Fn();console.log(a.user); //追梦子 这里的对象a能够点出函数fn的user，是因为new关键字可以改变this的指向，将这个this指向对象a，a之所以是一个对象，是因为new关键字是创建一个对象。 3、当this碰到return1234567function fn() &#123; this.user = '追梦子'; return &#123;&#125;; &#125;var a = new fn; console.log(a.user); //undefined 1234567function fn() &#123; this.user = '追梦子'; return function()&#123;&#125;;&#125;var a = new fn; console.log(a.user); //undefined 1234567function fn() &#123; this.user = '追梦子'; return 1;&#125;var a = new fn; console.log(a.user); //追梦子 1234567function fn() &#123; this.user = '追梦子'; return undefined; //替换成 return null 结果也是这样;&#125;var a = new fn; console.log(a.user); //追梦子 如果返回值是一个对象，那么this指向的就是这个对象，如果返回的不是一个对象，那么指向的还是函数的实例。 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 三、for循环经典列子 例子1： 1234567891011window.onload = function()&#123; var box = document.getElementById("box"); var num = 0; function a()&#123; console.log(num); &#125; box.onclick = function()&#123; num ++; a(); // 1,2,3,4....每次单击都会加1，说明函数引用外部变量是引用那个变量的最后一次的值。 &#125;&#125; 例子2： 123456789window.onload = function()&#123; var box = document.getElementById("box"); var num = 0; for(var i=0;i&lt;10;i++)&#123; box.onclick = function()&#123; console.log(i); //总是打印10 &#125; &#125;&#125; 例子2中，每次点击都是打印10，而不是打印1,2,3,4…，这是为什么呢？因为当你for循环时，并没有执行这个函数，当你点击的时候执行此函数，它会发现它没有此变量i，于是向它的作用域链中查找此变量，而此时变量i的值为10，所有每次点击后输出的结果都为10。 例子3： 1234567891011window.onload = function()&#123; var div = document.getElementsByTagName("div"); var num = 0; for(var i=0;i&lt;div.length;i++)&#123; (function(i)&#123; div[i].onclick = function()&#123; console.log(i); //1,2,3,4..... &#125; &#125;)(i) &#125; &#125; 上面代码能够实现每次点击都出现不同的数字，但是这样会将i一直保存在内存中，比较消耗性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fhexo%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、使用Hexo+Github一步步搭建属于自己的博客（基础）​ http://www.cnblogs.com/fengxiongZz/p/7707219.html 2、关于这个博客主题 Hexo-Theme-Buer使用​ https://blog.csdn.net/erchowyo/article/details/54407614/ 3、有哪些好看的 Hexo 主题​ https://www.zhihu.com/question/24422335 4、修改hexo后同步到github ​ hexo clean ​ hexo d ​ hexo g]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fvue%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、新建一个vue-cli项目文件1、安装vue脚手架输入：​ vue init webpack exprice 注意这里的“exprice” 是项目的名称可以说是随便的起名，但是需要主要的是“不能用中文” 2、安装依赖输入：​ npm install 3、启动项目输入：​ npm run dev 二、页面间传值this.$router.replace(‘/index’)也可以跳转页面 跳转并传值：​ 123456789methods: &#123; ​ login () &#123; this.$router.push(&#123;name: &apos;index&apos;,params: &#123;username: this.username,password: this.password&#125;&#125;); &#125;​ &#125; 注解：index是将要跳转的一个index.vue页面，params后面是传的参数，先在data里面声明 接收值：​ $route.params.username、$route.params.password接收传过来的两个值 三、父组件往子组件传值父组件可以使用 props 把数据传给子组件。 父组件：​ 注解：component-a是导入的子组件，msgfromfather是要传的key 子组件：​ props: [‘msgfromfather’] //和定义方法、变量一样需要定义 ​ console.log(this.msgfromfather) //可以在方法里面打印出传过来的值 ​ //可以在页面直接显示 四、子组件往父组件传值子组件可以使用 $emit 触发父组件的自定义事件。 子组件：​ this.$emit(“child-speak”,this.msg); //写在方法里面，比如点击之后就执行这个方法，child-speak是父组件自定义的事件 父组件：​ //child-speak是自定义的事件，getchildspeak是方法 ​ getchildspeak: function (msg) { this.childwords = msg;} //通过这个方法就可以得到传过来的msg代表什么值 ​ //显示出来接收到的值 五、路由1、动态路由123456789export default new Router(&#123; routes: [ &#123; path: &apos;/goods/:goodsId/user/:name&apos;, name: &apos;GoodsList&apos;, component: GoodsList &#125; ]&#125;) 浏览器地址栏：http://localhost:8081/#/goods/111/user/admin path: ‘/goods/:goodsId/user/:name’ 或者 path: ‘/goods/:goodsId 这是配置路由，: 后面是要携带的参数 ​ $route.params.goodsId ​ 或者 $ route.params.name 这是在跳转后获取携带的参数值 2、嵌套路由路由设置123456789101112131415161718192021export default new Router(&#123; routes: [ &#123; path: &apos;/goods&apos;, name: &apos;GoodsList&apos;, component: GoodsList, children: [ &#123; path: &apos;title&apos;, name: &apos;title&apos;, component: Title &#125;, &#123; path: &apos;image&apos;, name: &apos;image&apos;, component: Image &#125; ] &#125; ]&#125;) GoodsList.vue页面设置12345678&lt;div&gt; 这是商品列表页面&lt;br/&gt; &lt;router-link to=&quot;/goods/title&quot;&gt;显示商品标题&lt;/router-link&gt; &lt;router-link to=&quot;/goods/image&quot;&gt;显示商品图片&lt;/router-link&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 3、编程式路由1&lt;button @click=&quot;jump&quot;&gt;跳转到购物车页面&lt;/button&gt; 123456789export default &#123; name: &quot;goods-list&quot;, methods: &#123; jump() &#123; // this.$router.push(&quot;/cart&quot;) this.$router.push(&#123;path: &apos;/cart?goodsId=123&apos;&#125;) &#125; &#125;&#125; 4、命名路由1&lt;router-link v-bind:to=&quot;&#123;name:&apos;cart&apos;,params:&#123;cartId:123&#125;&#125;&quot;&gt;跳转到购物车页面--命名路由&lt;/router-link&gt; 注意：to前面要用v-bind，不然没效果 12345&#123; path: &apos;/cart/:cartId&apos;, name: &apos;cart&apos;, component: Cart,&#125; 六、浏览器顶部地址栏默认：http://localhost:8081/#/goods 有一个”/#“ mode:’hash’,这句是隐藏默认的 修改后：index.js: 12345678910export default new Router(&#123; mode:&apos;history&apos;, routes: [ &#123; path: &apos;/goods&apos;, name: &apos;GoodsList&apos;, component: GoodsList &#125; ]&#125;) 在index.js里面添加mode:’history’,然后浏览器地址就不用“/#”，http://localhost:8081/goods 七、$route.query.xxx和$route.params.xxx$route.query.xxx是获取通过this.$router.push({path: ‘/cart?goodsId=123’})这种方式传递的值 $route.params.xxx是获取组件与组件切换传递的值 八、mounted、methods、computed12345678910111213mounted: function() &#123; this.run(); &#125;, methods: &#123; run() &#123; &#125; &#125;, computed: &#123; reversedMessage: function () &#123; return this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; mounted：进入页面自动会执行的 methods：比如点击事件需要执行的函数 computed：计算属性，当绑定的值改变时就会执行]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm 笔记]]></title>
    <url>%2F2018%2F04%2F26%2Fssm%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、SpringMVC接口解释（1）DispatcherServlet接口：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给 Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。 是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：（1）截获符合特定格式的URL请求。（2）初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。（3）初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 （2）HandlerMapping接口：能够完成客户请求到Controller映射。 （3）Controller接口：需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 （4）ViewResolver接口：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。 二、xml文件各种标签属性（1）12341.我们只需在Spring容器能加载到的地方配置bean就可以把自定义类加入到Spring容器中，注意：我们配置的bean是实现类，而不是接口！！ 2.我们可以直接在我们的impl类中配置@service，把相应的类注入到spring容器中。切记这两种方式都可以注入说明：在配置文件中配置bean，其实就是在Spring容器中注入类，这个类在Spring容器中有唯一一个表示id,我们可以通过Spring容器去管理这个类，非常方便（类似ios中的ARC自动释放池）； 三、springmvc常用注解标签（1）@Controller​ 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 ​ @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： （1）在SpringMVC 的配置文件中定义MyController 的bean 对象。 ​ （2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 ​ &lt; context:component-scan base-package = “com.host.app.web” /&gt;//路径写到controller的上一层 （2）@RequestMapping​ RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。 1、 value， method； value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； 2、consumes，produces consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； 3、params，headers params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 （3）@Resource和@Autowired​ @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。 1、共同点 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 2、不同点 @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。 12345public class TestServiceImpl &#123; @Autowired @Qualifier(&quot;userDao&quot;) private UserDao userDao; &#125; @Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 public class TestServiceImpl { // 下面两种@Resource只要使用一种即可 @Resource(name=&quot;userDao&quot;) private UserDao userDao; // 用于字段上 @Resource(name=&quot;userDao&quot;) public void setUserDao(UserDao userDao) { // 用于属性的setter方法上 this.userDao = userDao; } } 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。 @Resource装配顺序： ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。 @Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 （4）、@ModelAttribute和 @SessionAttributes​ 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。 @SessionAttributes即将值放到session作用域中，写在class上面。 使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据 （5）、@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数 123456789101112131415161718192021@Controller public class TestController &#123; @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId, @PathVariable(&quot;roleId&quot;) String roleId)&#123; System.out.println(&quot;User Id : &quot; + userId); System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;; &#125; @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET) public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123; System.out.println(&quot;Product Id : &quot; + productId); return &quot;hello&quot;; &#125; @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;, method = RequestMethod.GET) public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123; System.out.println(&quot;URI Part 1 : &quot; + regexp1); return &quot;hello&quot;; &#125; &#125; （6）、@requestParam@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 （7）、@ResponseBody作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； （8）、@Component相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。 （9）、@Repository用于注解dao层，在daoImpl类上面注解。 ​ 1：@Repository 用于对DAO实现类进行注解。​ 2：@Service 用于对业务层注解，但是目前该功能与 @Component 相同。​ 3：@Constroller用于对控制层注解，但是目前该功能与 @Component 相同。 （10）、@Service首先，在applicationContext.xml文件中加一行： 1&lt;context:component-scan base-package=&quot;com.hzhi.clas&quot;/&gt; 加上这一行以后，将自动扫描路径下面的包，如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml文件定义bean了，类似的还包括@Component、@Repository、@Controller。 比如下面这个类： 1234567@Service(&quot;courseDAO&quot;)@Scope(&quot;prototype&quot;)public class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO&#123; ...... &#125;[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);) 其作用就相当于applicationContext.xml文件里面的： 1234&lt;bean id=&quot;courseDAO&quot; class=&quot;com.hzhi.course.dao.CourseDAOImpl&quot; scope=&quot;prototype&quot;&gt; ...... &lt;/bean&gt; 四、springmvc视图解析返回html页面报404错误注意配置html视图解析器时，出现了404错误，仔细了解 当一次请求是需要经过两次拦截器，即html–&gt;拦截器–&gt;controller–&gt;拦截器—&gt;html，其中如果按照下面配置，第一次请求拦截器是正确的，第二次拦截就包404错误。 解决方法： 第一种，使用标题配置“html”视图解析器这样配置，个人推荐这种配置。注意这种配置html是没有前缀属性的，所以需要先配置freemarkerConfig，前缀保存在freemarkerConfig中。 第二种，在web.xml中加入下面代码，表示对静态资源.html不拦截。 &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; 第三种，使用 &lt;mvc:resources location=”/“ mapping=”/*/.html”/&gt; 五、ssm前后端分离注意：要导入json相应的包！ 控制器前面用@RestController就不用在方法上面加@responsebody。 控制器前面用@Controller，就要在方法前面加上@responsebody 123456789101112131415//返回json数据(测试) @RequestMapping(&quot;/selectEmployee.do&quot;) public List&lt;Employee&gt; selectEmployee(Employee employee)&#123;// List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();// for (int i = 0; i &lt; 3; i++) &#123;// Employee employee = new Employee();// employee.setId(5+i);// employee.setName(&quot;张&quot;+i);;// employees.add(employee);// &#125;// return employees; List&lt;Employee&gt; employeesList = employeeService.getEmployees(employee); return employeesList; &#125; 访问的时候：地址/项目名/selectEmployee.do（http://localhost:8080/jxc/selectEmployee.do）]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
